#!/usr/bin/env bash

# Test mise prepare (mise prep) command

# Test --list with no providers configured
assert_contains "mise prepare --list" "No prepare providers found"

# Create a package-lock.json (npm provider needs to be configured to detect it)
cat >package-lock.json <<'EOF'
{
  "name": "test-project",
  "lockfileVersion": 3,
  "packages": {}
}
EOF

# Still no providers without explicit config
assert_contains "mise prepare --list" "No prepare providers found"

# Configure npm provider explicitly
cat >mise.toml <<'EOF'
[prepare.npm]
EOF

# Now npm provider should be detected
assert_contains "mise prepare --list" "npm"
assert_contains "mise prepare --list" "package-lock.json"
assert_contains "mise prepare --list" "node_modules"

# Test --dry-run shows what would run
assert_contains "mise prepare --dry-run" "npm"

# Test alias works
assert_contains "mise prep --list" "npm"

# Test with custom prepare provider (no .rules. prefix)
cat >mise.toml <<'EOF'
[prepare.npm]

[prepare.codegen]
sources = ["schema.graphql"]
outputs = ["generated/"]
run = "echo codegen"
EOF

# Create source file
touch schema.graphql

assert_contains "mise prepare --list" "codegen"
assert_contains "mise prepare --list" "schema.graphql"

# Test --only flag
assert_contains "mise prepare --dry-run --only codegen" "codegen"
assert_not_contains "mise prepare --dry-run --only codegen" "npm"

# Test --skip flag
assert_not_contains "mise prepare --dry-run --skip npm" "npm install"

# Test disable in config
cat >mise.toml <<'EOF'
[prepare]
disable = ["npm"]

[prepare.npm]

[prepare.codegen]
sources = ["schema.graphql"]
outputs = ["generated/"]
run = "echo codegen"
EOF

assert_not_contains "mise prepare --list" "npm"
assert_contains "mise prepare --list" "codegen"

# Test per-provider auto flag
cat >mise.toml <<'EOF'
[prepare.npm]
auto = true

[prepare.codegen]
auto = false
sources = ["schema.graphql"]
outputs = ["generated/"]
run = "echo codegen"
EOF

# Both should show in list
assert_contains "mise prepare --list" "npm"
assert_contains "mise prepare --list" "codegen"

# Test yarn provider
rm -f package-lock.json
cat >yarn.lock <<'EOF'
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
EOF

cat >mise.toml <<'EOF'
[prepare.yarn]
EOF

assert_contains "mise prepare --list" "yarn"
assert_contains "mise prepare --list" "yarn.lock"
assert_contains "mise prepare --dry-run" "yarn"

# Test pnpm provider
rm -f yarn.lock
cat >pnpm-lock.yaml <<'EOF'
lockfileVersion: '9.0'
EOF

cat >mise.toml <<'EOF'
[prepare.pnpm]
EOF

assert_contains "mise prepare --list" "pnpm"
assert_contains "mise prepare --list" "pnpm-lock.yaml"
assert_contains "mise prepare --dry-run" "pnpm"

# Test bun provider (binary lockfile)
rm -f pnpm-lock.yaml
touch bun.lockb

cat >mise.toml <<'EOF'
[prepare.bun]
EOF

assert_contains "mise prepare --list" "bun"
assert_contains "mise prepare --list" "bun.lockb"
assert_contains "mise prepare --dry-run" "bun"

# Test bun provider (text lockfile)
rm -f bun.lockb
cat >bun.lock <<'EOF'
# bun lockfile
EOF

assert_contains "mise prepare --list" "bun"
assert_contains "mise prepare --list" "bun.lock"

# Test go provider
rm -f bun.lock
cat >go.sum <<'EOF'
github.com/foo/bar v1.0.0 h1:abc
EOF
cat >go.mod <<'EOF'
module test
go 1.21
EOF
# Ensure go.sum (output) is older than go.mod (source) to trigger staleness
touch -t 202301010000 go.sum

cat >mise.toml <<'EOF'
[prepare.go]
EOF

assert_contains "mise prepare --list" "go"
assert_contains "mise prepare --list" "go.sum"
assert_contains "mise prepare --dry-run" "go"

# Test pip provider
rm -f go.sum go.mod
cat >requirements.txt <<'EOF'
requests==2.31.0
EOF

cat >mise.toml <<'EOF'
[prepare.pip]
EOF

assert_contains "mise prepare --list" "pip"
assert_contains "mise prepare --list" "requirements.txt"
assert_contains "mise prepare --dry-run" "pip"

# Test poetry provider
rm -f requirements.txt
cat >poetry.lock <<'EOF'
[[package]]
name = "requests"
version = "2.31.0"
EOF
cat >pyproject.toml <<'EOF'
[tool.poetry]
name = "test"
EOF

cat >mise.toml <<'EOF'
[prepare.poetry]
EOF

assert_contains "mise prepare --list" "poetry"
assert_contains "mise prepare --list" "poetry.lock"
assert_contains "mise prepare --dry-run" "poetry"

# Test uv provider
rm -f poetry.lock
cat >uv.lock <<'EOF'
version = 1
EOF

cat >mise.toml <<'EOF'
[prepare.uv]
EOF

assert_contains "mise prepare --list" "uv"
assert_contains "mise prepare --list" "uv.lock"
assert_contains "mise prepare --dry-run" "uv"

# Test bundler provider
rm -f uv.lock pyproject.toml
cat >Gemfile.lock <<'EOF'
GEM
  specs:
EOF
cat >Gemfile <<'EOF'
source 'https://rubygems.org'
EOF

cat >mise.toml <<'EOF'
[prepare.bundler]
EOF

assert_contains "mise prepare --list" "bundler"
assert_contains "mise prepare --list" "Gemfile.lock"
assert_contains "mise prepare --dry-run" "bundler"

# Test composer provider
rm -f Gemfile.lock Gemfile
cat >composer.lock <<'EOF'
{
    "_readme": ["This file locks the dependencies"]
}
EOF
cat >composer.json <<'EOF'
{}
EOF

cat >mise.toml <<'EOF'
[prepare.composer]
EOF

assert_contains "mise prepare --list" "composer"
assert_contains "mise prepare --list" "composer.lock"
assert_contains "mise prepare --dry-run" "composer"

# Test freshness detection with content hashing
rm -f composer.lock composer.json

cat >mise.toml <<'EOF'
[prepare.custom_venv]
sources = ["requirements.txt"]
outputs = [".venv"]
run = "echo PREPARE_RAN"
EOF

cat >requirements.txt <<'EOF'
requests==2.31.0
EOF

# Test 1: No output directory exists → should be stale (outputs missing)
rm -rf .venv .mise
assert_contains "mise prepare --dry-run" "custom_venv"
assert_contains "mise prepare --dry-run" "outputs missing"

# Test 2: Run prepare to establish state, then check freshness
mkdir -p .venv
assert_contains "mise prepare --only custom_venv" "Prepared: custom_venv"

# Second run: sources unchanged, should be fresh (content hashes match)
assert_not_contains "mise prepare --dry-run" "custom_venv"

# Test 3: Change source content → should be stale
echo "flask==3.0.0" >>requirements.txt
assert_contains "mise prepare --dry-run" "custom_venv"
assert_contains "mise prepare --dry-run" "requirements.txt changed"

# Clean up
rm -rf .venv requirements.txt .mise
rm -f composer.lock composer.json package.json mise.toml schema.graphql

# Test --explain flag
cat >mise.toml <<'EOF'
[prepare.explain_test]
auto = true
sources = ["src_input.txt"]
outputs = ["out_dir"]
run = "echo explain_ran"
EOF

touch src_input.txt

# Test --explain with missing output (stale)
rm -rf out_dir
mise prepare explain_test --explain >.explain_out 2>&1 || true
assert_contains "cat .explain_out" "Provider: explain_test"
assert_contains "cat .explain_out" "Auto: yes"
assert_contains "cat .explain_out" "Sources:"
assert_contains "cat .explain_out" "Outputs:"
assert_contains "cat .explain_out" "Command: echo explain_ran"
assert_contains "cat .explain_out" "stale"

# Test --explain with fresh output (run prepare first to establish state)
mkdir -p out_dir
mise prepare --only explain_test >/dev/null 2>&1 || true
mise prepare explain_test --explain >.explain_out 2>&1
assert_contains "cat .explain_out" "Provider: explain_test"
assert_contains "cat .explain_out" "fresh"

# Test --explain with unknown provider
mise prepare nonexistent --explain >.explain_out 2>&1 || true
assert_contains "cat .explain_out" "not found"

rm -rf src_input.txt out_dir mise.toml .explain_out

# Test content-hash freshness: after a successful run, state is saved and provider is fresh
cat >mise.toml <<'EOF'
[prepare.hash_test]
sources = ["src_file.txt"]
outputs = ["out_dir"]
run = "echo HASH_RAN"
EOF

echo "original content" >src_file.txt
mkdir -p out_dir

# First run: should execute (no previous state)
assert_contains "mise prepare --only hash_test" "Prepared: hash_test"

# Second run: sources unchanged, should be fresh (hashes saved in state)
assert_contains "mise prepare --only hash_test" "up to date"

# Modify source content → should be stale again
echo "modified content" >src_file.txt
assert_contains "mise prepare --only hash_test" "Prepared: hash_test"

# Third run after re-prepare: fresh again
assert_contains "mise prepare --only hash_test" "up to date"

rm -rf src_file.txt out_dir .mise

# Test timeout: a command that exceeds its timeout should fail
cat >mise.toml <<'EOF'
[prepare.timeout_test]
sources = ["src_file.txt"]
outputs = ["out_dir"]
run = "sleep 30"
timeout = "2s"
EOF

touch src_file.txt
mkdir -p out_dir
# Make source newer than output so provider is stale
touch -t 202501010000 out_dir
touch -t 202601010000 src_file.txt

# Should fail because sleep 30 exceeds the 2-second timeout
assert_fail "mise prepare --only timeout_test"

rm -rf src_file.txt out_dir mise.toml

# Test that prepare providers are NOT inherited from parent config files
# (monorepo scenario: root defines [prepare.pnpm], subdirectory should not inherit it)
mkdir -p subproject

cat >mise.toml <<'EOF'
[prepare.custom_root]
sources = ["root_input.txt"]
outputs = ["root_output.txt"]
run = "echo root_ran"
EOF
touch root_input.txt

cat >subproject/mise.toml <<'EOF'
[prepare.custom_sub]
sources = ["sub_input.txt"]
outputs = ["sub_output.txt"]
run = "echo sub_ran"
EOF
touch subproject/sub_input.txt

# From root: only root provider should be visible
assert_contains "mise prepare --list" "custom_root"
assert_not_contains "mise prepare --list" "custom_sub"

# From subdirectory: only subdirectory provider should be visible, not inherited root
(
	cd subproject
	assert_contains "mise prepare --list" "custom_sub"
	assert_not_contains "mise prepare --list" "custom_root"
)

# Clean up previous test
rm -rf subproject root_input.txt root_output.txt mise.toml .mise

# Test that monorepo subdirectory prepare steps run when using //subdir:task from root
export MISE_EXPERIMENTAL=1
mkdir -p subapp

cat >mise.toml <<'EOF'
experimental_monorepo_root = true

[monorepo]
config_roots = ["subapp"]
EOF

cat >subapp/mise.toml <<'EOF'
[prepare.subapp_deps]
auto = true
sources = ["input.txt"]
outputs = ["deps_marker"]
run = "touch deps_marker"

[tasks.check]
run = "test -f deps_marker && echo SUBAPP_PREPARE_OK || echo SUBAPP_PREPARE_MISSING"
EOF

touch subapp/input.txt

# Run the task from root using monorepo syntax
assert_contains "mise run //subapp:check" "SUBAPP_PREPARE_OK"

# Test that prepare steps also run when subtasks are reached via dependencies
cat >mise.toml <<'EOF'
experimental_monorepo_root = true

[monorepo]
config_roots = ["subapp"]

[tasks.check]
depends = "//...:check"
EOF

touch subapp/input.txt
rm -f subapp/deps_marker
assert_contains "mise run //:check" "SUBAPP_PREPARE_OK"

# Clean up
rm -rf subapp mise.toml .mise

# Test git-submodule provider
cat >.gitmodules <<'EOF'
[submodule "libs/foo"]
	path = libs/foo
	url = https://example.com/foo.git
[submodule "libs/bar"]
	path = libs/bar
	url = https://example.com/bar.git
EOF

cat >mise.toml <<'EOF'
[prepare.git-submodule]
EOF

assert_contains "mise prepare --list" "git-submodule"
assert_contains "mise prepare --list" ".gitmodules"
assert_contains "mise prepare --list" "libs/foo"
assert_contains "mise prepare --list" "libs/bar"

# Test that empty .gitmodules is not applicable
echo -n "" >.gitmodules
cat >mise.toml <<'EOF'
[prepare.git-submodule]
EOF
assert_not_contains "mise prepare --list" "git-submodule"

# Clean up
rm -f .gitmodules mise.toml .mise
