#!/usr/bin/env bash

set -euo pipefail

export MISE_EXPERIMENTAL=1

# Test uv is used for manually defined venv
cat >mise.toml <<EOF
[env._.python]
venv = {path = "my_venv", create=true}

[tools]
python = "3.12.3"
uv = "0.5.4"
EOF

mise i
assert "mise x -- python --version" "Python 3.12.3"
assert_contains "mise x -- uv --version" "uv 0.5.4"
assert "mise env -s bash | grep VIRTUAL_ENV" "export VIRTUAL_ENV=$PWD/my_venv"
assert "mise x -- which python" "$PWD/my_venv/bin/python"
assert_not_contains "ls $PWD/my_venv/" "include" # stdlib virtual venv has an "include" folder while uv doesn't

# Test "source" mode - only sources existing venv, doesn't create
rm -rf .venv
rm -f uv.lock

cat >mise.toml <<EOF
[tools]
python = "3.12.3"
uv = "0.5.4"

[settings]
python.uv_venv_auto = "source"
EOF

touch uv.lock

# Without a .venv, should use system python path (not .venv)
assert_not_contains "mise env -s bash" "VIRTUAL_ENV"

# Create venv manually
mise x -- uv venv

# Now it should source the existing venv
assert_contains "mise env -s bash" "VIRTUAL_ENV=$PWD/.venv"
assert "mise x -- which python" "$PWD/.venv/bin/python"
# source mode should NOT set UV_PYTHON
assert_not_contains "mise env -s bash" "UV_PYTHON"

# Test "create|source" mode - creates venv if missing, sources it
rm -rf .venv

cat >mise.toml <<EOF
[tools]
python = "3.12.3"
uv = "0.5.4"

[settings]
python.uv_venv_auto = "create|source"
EOF

# Should create venv automatically and source it
assert_contains "mise env -s bash" "VIRTUAL_ENV=$PWD/.venv"
assert "mise x -- which python" "$PWD/.venv/bin/python"
# create|source mode should NOT set UV_PYTHON (unlike legacy true)
assert_not_contains "mise env -s bash" "UV_PYTHON"

# Test legacy "true" mode - should set UV_PYTHON
# this will be deprecated in future releases
rm -rf .venv

cat >mise.toml <<EOF
[tools]
python = "3.12.3"
uv = "0.5.4"

[settings]
python.uv_venv_auto = true
EOF

# Should create venv and source it
assert_contains "mise env -s bash" "VIRTUAL_ENV=$PWD/.venv"
assert "mise x -- which python" "$PWD/.venv/bin/python"
# legacy true mode SHOULD set UV_PYTHON
assert_contains "mise env -s bash" "UV_PYTHON"

# Test boolean parsing from env vars - "true","1", "yes",  should all work
rm -rf .venv

cat >mise.toml <<EOF
[tools]
python = "3.12.3"
uv = "0.5.4"
EOF

MISE_PYTHON_UV_VENV_AUTO=true assert_contains "mise env -s bash" "VIRTUAL_ENV=$PWD/.venv"
rm -rf .venv
MISE_PYTHON_UV_VENV_AUTO=yes assert_contains "mise env -s bash" "VIRTUAL_ENV=$PWD/.venv"
rm -rf .venv
MISE_PYTHON_UV_VENV_AUTO=1 assert_contains "mise env -s bash" "VIRTUAL_ENV=$PWD/.venv"

# Test "0", "no", "false" should disable
MISE_PYTHON_UV_VENV_AUTO=false assert_not_contains "mise env -s bash" "VIRTUAL_ENV"
MISE_PYTHON_UV_VENV_AUTO=no assert_not_contains "mise env -s bash" "VIRTUAL_ENV"
MISE_PYTHON_UV_VENV_AUTO=0 assert_not_contains "mise env -s bash" "VIRTUAL_ENV"

# Test shim exclusion: the mise uv shim must NOT be called internally when creating
# a venv via uv_venv_auto â€” doing so would trigger `mise exec`, which re-enters
# env resolution and causes infinite subprocess recursion.
rm -rf .venv uv.lock
mkdir -p "$MISE_DATA_DIR/shims"
rm -f "$MISE_DATA_DIR/shims/uv"
cat >"$MISE_DATA_DIR/shims/uv" <<'SHIM'
#!/bin/bash
echo "ERROR: mise uv shim was invoked during venv creation" >&2
exit 99
SHIM
chmod +x "$MISE_DATA_DIR/shims/uv"
ORIG_PATH="$PATH"
export PATH="$MISE_DATA_DIR/shims:$PATH"
cat >mise.toml <<EOF
[settings]
python.uv_venv_auto = "create|source"
EOF
touch uv.lock
# which_no_shims() skips $MISE_DATA_DIR/shims, so the fake shim is never called;
# since no real uv is available either, venv creation is silently skipped.
output=$(mise env -s bash 2>&1 || true)
assert_not_contains "printf '%s' \"$output\"" "ERROR: mise uv shim was invoked during venv creation"
rm -f "$MISE_DATA_DIR/shims/uv" uv.lock
export PATH="$ORIG_PATH"

## Allows opt-out uv's venv
#mkdir -p subdir
#cat >subdir/mise.toml <<EOF
#[env._.python]
#venv = {path = "my_subvenv", create=true}
#[tools]
#python = "3.12.3"
#uv = "0.5.4"
#[settings]
#python_venv_stdlib = true
#EOF
#
#cd subdir || exit 1
#mise i
#assert "mise x -- python --version" "Python 3.12.3"
#assert "mise env -s bash | grep VIRTUAL_ENV" "export VIRTUAL_ENV=$PWD/my_subvenv"
#assert "mise x -- which python" "$PWD/my_subvenv/bin/python"
#assert_contains "ls $PWD/my_subvenv/" "include" # stdlib virtual venv has an "include" folder while uv doesn't
#
#cd .. || exit 1
#cat >mise.toml <<EOF
#[tools]
#python = "3.12.3"
#uv = "0.5.4"
#[settings]
#python.uv_venv_auto = "source"
#EOF
#touch uv.lock
#
#assert "mise x -- which python" "$PWD/.venv/bin/python"
#assert "mise env -s bash | grep VIRTUAL_ENV" "export VIRTUAL_ENV=$PWD/.venv"
#assert "mise env -D | grep UV_PYTHON" "UV_PYTHON=3.12.3"
#assert_not_contains "ls $PWD/.venv" "include" # stdlib virtual venv has an "include" folder while uv doesn't
